{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nvar SELECTION_FORWARD = 'forward';\nvar SELECTION_BACKWARD = 'backward';\n/**\n * {@docCategory Autofill}\n */\nvar Autofill = /** @class */function (_super) {\n  __extends(Autofill, _super);\n  function Autofill(props) {\n    var _this = _super.call(this, props) || this;\n    _this._inputElement = React.createRef();\n    _this._autoFillEnabled = true;\n    // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n    _this._onCompositionStart = function (ev) {\n      _this.setState({\n        isComposing: true\n      });\n      _this._autoFillEnabled = false;\n    };\n    // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n    _this._onCompositionUpdate = function () {\n      if (isIE11()) {\n        _this._updateValue(_this._getCurrentInputValue(), true);\n      }\n    };\n    // Composition events are used when the character/text requires several keystrokes to be completed.\n    // Some examples of this are mobile text input and languages like Japanese or Arabic.\n    // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n    _this._onCompositionEnd = function (ev) {\n      var inputValue = _this._getCurrentInputValue();\n      _this._tryEnableAutofill(inputValue, _this.value, false, true);\n      _this.setState({\n        isComposing: false\n      });\n      // Due to timing, this needs to be async, otherwise no text will be selected.\n      _this._async.setTimeout(function () {\n        // it's technically possible that the value of isComposing is reset during this timeout,\n        // so explicitly trigger this with composing=true here, since it is supposed to be the\n        // update for composition end\n        _this._updateValue(_this._getCurrentInputValue(), false);\n      }, 0);\n    };\n    _this._onClick = function () {\n      if (_this.value && _this.value !== '' && _this._autoFillEnabled) {\n        _this._autoFillEnabled = false;\n      }\n    };\n    _this._onKeyDown = function (ev) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      }\n      // If the event is actively being composed, then don't alert autofill.\n      // Right now typing does not have isComposing, once that has been fixed any should be removed.\n      if (!ev.nativeEvent.isComposing) {\n        // eslint-disable-next-line deprecation/deprecation\n        switch (ev.which) {\n          case KeyCodes.backspace:\n            _this._autoFillEnabled = false;\n            break;\n          case KeyCodes.left:\n          case KeyCodes.right:\n            if (_this._autoFillEnabled) {\n              _this.setState({\n                inputValue: _this.props.suggestedDisplayValue || ''\n              });\n              _this._autoFillEnabled = false;\n            }\n            break;\n          default:\n            if (!_this._autoFillEnabled) {\n              // eslint-disable-next-line deprecation/deprecation\n              if (_this.props.enableAutofillOnKeyPress.indexOf(ev.which) !== -1) {\n                _this._autoFillEnabled = true;\n              }\n            }\n            break;\n        }\n      }\n    };\n    _this._onInputChanged = function (ev) {\n      var value = _this._getCurrentInputValue(ev);\n      if (!_this.state.isComposing) {\n        _this._tryEnableAutofill(value, _this.value, ev.nativeEvent.isComposing);\n      }\n      // If it is not IE11 and currently composing, update the value\n      if (!(isIE11() && _this.state.isComposing)) {\n        var nativeEventComposing = ev.nativeEvent.isComposing;\n        var isComposing = nativeEventComposing === undefined ? _this.state.isComposing : nativeEventComposing;\n        _this._updateValue(value, isComposing);\n      }\n    };\n    _this._onChanged = function () {\n      // Swallow this event, we don't care about it\n      // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n      return;\n    };\n    /**\n     * Updates the current input value as well as getting a new display value.\n     * @param newValue - The new value from the input\n     */\n    _this._updateValue = function (newValue, composing) {\n      // Only proceed if the value is nonempty and is different from the old value\n      // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n      if (!newValue && newValue === _this.value) {\n        return;\n      }\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n        onInputChange = _a.onInputChange,\n        onInputValueChange = _a.onInputValueChange,\n        updateValueInWillReceiveProps = _a.updateValueInWillReceiveProps;\n      if (onInputChange) {\n        newValue = (onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(newValue, composing)) || '';\n      }\n      // if value is controlled in updateValueInWillReceiveProps, then we should not update the value in state now\n      // https://github.com/microsoft/fluentui/issues/18499\n      updateValueInWillReceiveProps ? onInputValueChange === null || onInputValueChange === void 0 ? void 0 : onInputValueChange(newValue, composing) : _this.setState({\n        inputValue: newValue\n      }, function () {\n        return onInputValueChange === null || onInputValueChange === void 0 ? void 0 : onInputValueChange(newValue, composing);\n      });\n    };\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this.state = {\n      inputValue: props.defaultVisibleValue || '',\n      isComposing: false\n    };\n    return _this;\n  }\n  Autofill.getDerivedStateFromProps = function (props, state) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      var updatedInputValue = props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {\n        return __assign(__assign({}, state), {\n          inputValue: updatedInputValue\n        });\n      }\n    }\n    return null;\n  };\n  Object.defineProperty(Autofill.prototype, \"cursorLocation\", {\n    get: function () {\n      if (this._inputElement.current) {\n        var inputElement = this._inputElement.current;\n        if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n          return inputElement.selectionEnd;\n        } else {\n          return inputElement.selectionStart;\n        }\n      } else {\n        return -1;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"isValueSelected\", {\n    get: function () {\n      return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"value\", {\n    get: function () {\n      return this._getControlledValue() || this.state.inputValue || '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionStart\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"selectionEnd\", {\n    get: function () {\n      return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Autofill.prototype, \"inputElement\", {\n    get: function () {\n      return this._inputElement.current;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Autofill.prototype.componentDidUpdate = function (_, _1, cursor) {\n    var _a = this.props,\n      suggestedDisplayValue = _a.suggestedDisplayValue,\n      shouldSelectFullInputValueInComponentDidUpdate = _a.shouldSelectFullInputValueInComponentDidUpdate,\n      preventValueSelection = _a.preventValueSelection;\n    var differenceIndex = 0;\n    if (preventValueSelection) {\n      return;\n    }\n    var isFocused = this._inputElement.current && this._inputElement.current === document.activeElement;\n    if (isFocused && this._autoFillEnabled && this.value && suggestedDisplayValue && _doesTextStartWith(suggestedDisplayValue, this.value)) {\n      var shouldSelectFullRange = false;\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n      if (shouldSelectFullRange) {\n        this._inputElement.current.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (differenceIndex < this.value.length && this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0) {\n          this._inputElement.current.setSelectionRange(differenceIndex, suggestedDisplayValue.length, SELECTION_BACKWARD);\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled && !this.state.isComposing) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  };\n  Autofill.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n  Autofill.prototype.render = function () {\n    var nativeProps = getNativeProps(this.props, inputProperties);\n    var style = __assign(__assign({}, this.props.style), {\n      fontFamily: 'inherit'\n    });\n    return React.createElement(\"input\", __assign({\n      autoCapitalize: \"off\",\n      autoComplete: \"off\",\n      \"aria-autocomplete\": 'both'\n    }, nativeProps, {\n      style: style,\n      ref: this._inputElement,\n      value: this._getDisplayValue(),\n      onCompositionStart: this._onCompositionStart,\n      onCompositionUpdate: this._onCompositionUpdate,\n      onCompositionEnd: this._onCompositionEnd,\n      // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n      onChange: this._onChanged,\n      onInput: this._onInputChanged,\n      onKeyDown: this._onKeyDown,\n      onClick: this.props.onClick ? this.props.onClick : this._onClick,\n      \"data-lpignore\": true\n    }));\n  };\n  Autofill.prototype.focus = function () {\n    this._inputElement.current && this._inputElement.current.focus();\n  };\n  Autofill.prototype.clear = function () {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  };\n  Autofill.prototype.getSnapshotBeforeUpdate = function () {\n    var _a, _b;\n    var inel = this._inputElement.current;\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: (_a = inel.selectionStart) !== null && _a !== void 0 ? _a : inel.value.length,\n        end: (_b = inel.selectionEnd) !== null && _b !== void 0 ? _b : inel.value.length,\n        dir: inel.selectionDirection || 'backward' || 'none'\n      };\n    }\n    return null;\n  };\n  Autofill.prototype._getCurrentInputValue = function (ev) {\n    if (ev && ev.target && ev.target.value) {\n      return ev.target.value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  };\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  Autofill.prototype._tryEnableAutofill = function (newValue, oldValue, isComposing, isComposed) {\n    if (!isComposing && newValue && this._inputElement.current && this._inputElement.current.selectionStart === newValue.length && !this._autoFillEnabled && (newValue.length > oldValue.length || isComposed)) {\n      this._autoFillEnabled = true;\n    }\n  };\n  Autofill.prototype._getDisplayValue = function () {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n    return this.value;\n  };\n  Autofill.prototype._getControlledValue = function () {\n    var value = this.props.value;\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    }\n    // eslint-disable-next-line no-console\n    console.warn(\"props.value of Autofill should be a string, but it is \" + value + \" with type of \" + typeof value);\n    return value.toString();\n  };\n  Autofill.defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up]\n  };\n  return Autofill;\n}(React.Component);\nexport { Autofill };\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\nfunction _getDisplayValue(inputValue, suggestedDisplayValue) {\n  var displayValue = inputValue;\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n  return displayValue;\n}\nfunction _doesTextStartWith(text, startWith) {\n  if (!text || !startWith) {\n    return false;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    for (var _i = 0, _a = [text, startWith]; _i < _a.length; _i++) {\n      var val = _a[_i];\n      if (typeof val !== 'string') {\n        throw new Error(Autofill.name + \" received non-string value \\\"\" + val + \"\\\" of type \" + typeof val + \" from either input's value or suggestedDisplayValue\");\n      }\n    }\n  }\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}","map":{"version":3,"names":["React","Async","getNativeProps","initializeComponentRef","inputProperties","isIE11","KeyCodes","SELECTION_FORWARD","SELECTION_BACKWARD","Autofill","_super","__extends","props","_this","call","_inputElement","createRef","_autoFillEnabled","_onCompositionStart","ev","setState","isComposing","_onCompositionUpdate","_updateValue","_getCurrentInputValue","_onCompositionEnd","inputValue","_tryEnableAutofill","value","_async","setTimeout","_onClick","_onKeyDown","onKeyDown","nativeEvent","which","backspace","left","right","suggestedDisplayValue","enableAutofillOnKeyPress","indexOf","_onInputChanged","state","nativeEventComposing","undefined","_onChanged","newValue","composing","_a","onInputChange","onInputValueChange","updateValueInWillReceiveProps","defaultVisibleValue","getDerivedStateFromProps","updatedInputValue","__assign","Object","defineProperty","prototype","get","current","inputElement","selectionDirection","selectionEnd","selectionStart","Boolean","_getControlledValue","componentDidUpdate","_","_1","cursor","shouldSelectFullInputValueInComponentDidUpdate","preventValueSelection","differenceIndex","isFocused","document","activeElement","_doesTextStartWith","shouldSelectFullRange","setSelectionRange","length","toLocaleLowerCase","start","end","dir","componentWillUnmount","dispose","render","nativeProps","style","fontFamily","createElement","autoCapitalize","autoComplete","ref","_getDisplayValue","onCompositionStart","onCompositionUpdate","onCompositionEnd","onChange","onInput","onClick","focus","clear","getSnapshotBeforeUpdate","inel","_b","target","oldValue","isComposed","console","warn","toString","defaultProps","down","up","Component","displayValue","text","startWith","process","env","NODE_ENV","_i","val","Error","name"],"sources":["E:\\SpringProjects\\Frontend\\frontend\\node_modules\\@fluentui\\react\\lib\\components\\src\\components\\Autofill\\Autofill.tsx"],"sourcesContent":["import * as React from 'react';\nimport { Async, getNativeProps, initializeComponentRef, inputProperties, isIE11, KeyCodes } from '../../Utilities';\nimport type { IAutofill, IAutofillProps } from './Autofill.types';\n\nexport interface IAutofillState {\n  inputValue: string;\n  isComposing: boolean;\n}\n\ninterface ICursorLocation {\n  start: number;\n  end: number;\n  dir: 'forward' | 'backward' | 'none' | undefined;\n}\n\nconst SELECTION_FORWARD = 'forward';\nconst SELECTION_BACKWARD = 'backward';\n\n/**\n * {@docCategory Autofill}\n */\nexport class Autofill extends React.Component<IAutofillProps, IAutofillState> implements IAutofill {\n  public static defaultProps = {\n    enableAutofillOnKeyPress: [KeyCodes.down, KeyCodes.up] as KeyCodes[],\n  };\n\n  private _inputElement = React.createRef<HTMLInputElement>();\n  private _autoFillEnabled = true;\n  private _async: Async;\n\n  public static getDerivedStateFromProps(props: IAutofillProps, state: IAutofillState): IAutofillState | null {\n    // eslint-disable-next-line deprecation/deprecation\n    if (props.updateValueInWillReceiveProps) {\n      // eslint-disable-next-line deprecation/deprecation\n      const updatedInputValue = props.updateValueInWillReceiveProps();\n      // Don't update if we have a null value or the value isn't changing\n      // the value should still update if an empty string is passed in\n      if (updatedInputValue !== null && updatedInputValue !== state.inputValue && !state.isComposing) {\n        return { ...state, inputValue: updatedInputValue };\n      }\n    }\n    return null;\n  }\n\n  constructor(props: IAutofillProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    this.state = {\n      inputValue: props.defaultVisibleValue || '',\n      isComposing: false,\n    };\n  }\n\n  public get cursorLocation(): number | null {\n    if (this._inputElement.current) {\n      const inputElement = this._inputElement.current;\n      if (inputElement.selectionDirection !== SELECTION_FORWARD) {\n        return inputElement.selectionEnd;\n      } else {\n        return inputElement.selectionStart;\n      }\n    } else {\n      return -1;\n    }\n  }\n\n  public get isValueSelected(): boolean {\n    return Boolean(this.inputElement && this.inputElement.selectionStart !== this.inputElement.selectionEnd);\n  }\n\n  public get value(): string {\n    return this._getControlledValue() || this.state.inputValue || '';\n  }\n\n  public get selectionStart(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionStart : -1;\n  }\n\n  public get selectionEnd(): number | null {\n    return this._inputElement.current ? this._inputElement.current.selectionEnd : -1;\n  }\n\n  public get inputElement(): HTMLInputElement | null {\n    return this._inputElement.current;\n  }\n\n  public componentDidUpdate(_: any, _1: any, cursor: ICursorLocation | null) {\n    const { suggestedDisplayValue, shouldSelectFullInputValueInComponentDidUpdate, preventValueSelection } = this.props;\n    let differenceIndex = 0;\n\n    if (preventValueSelection) {\n      return;\n    }\n\n    const isFocused = this._inputElement.current && this._inputElement.current === document.activeElement;\n\n    if (\n      isFocused &&\n      this._autoFillEnabled &&\n      this.value &&\n      suggestedDisplayValue &&\n      _doesTextStartWith(suggestedDisplayValue, this.value)\n    ) {\n      let shouldSelectFullRange = false;\n\n      if (shouldSelectFullInputValueInComponentDidUpdate) {\n        shouldSelectFullRange = shouldSelectFullInputValueInComponentDidUpdate();\n      }\n\n      if (shouldSelectFullRange) {\n        this._inputElement.current!.setSelectionRange(0, suggestedDisplayValue.length, SELECTION_BACKWARD);\n      } else {\n        while (\n          differenceIndex < this.value.length &&\n          this.value[differenceIndex].toLocaleLowerCase() === suggestedDisplayValue[differenceIndex].toLocaleLowerCase()\n        ) {\n          differenceIndex++;\n        }\n        if (differenceIndex > 0) {\n          this._inputElement.current!.setSelectionRange(\n            differenceIndex,\n            suggestedDisplayValue.length,\n            SELECTION_BACKWARD,\n          );\n        }\n      }\n    } else if (this._inputElement.current) {\n      if (cursor !== null && !this._autoFillEnabled && !this.state.isComposing) {\n        this._inputElement.current.setSelectionRange(cursor.start, cursor.end, cursor.dir);\n      }\n    }\n  }\n\n  public componentWillUnmount(): void {\n    this._async.dispose();\n  }\n\n  public render(): JSX.Element {\n    const nativeProps = getNativeProps<React.InputHTMLAttributes<HTMLInputElement>>(this.props, inputProperties);\n    const style = { ...this.props.style, fontFamily: 'inherit' };\n    return (\n      <input\n        autoCapitalize=\"off\"\n        autoComplete=\"off\"\n        aria-autocomplete={'both'}\n        {...nativeProps}\n        style={style}\n        ref={this._inputElement}\n        value={this._getDisplayValue()}\n        onCompositionStart={this._onCompositionStart}\n        onCompositionUpdate={this._onCompositionUpdate}\n        onCompositionEnd={this._onCompositionEnd}\n        // TODO (Fabric 8?) - switch to calling only onChange. See notes in TextField._onInputChange.\n        onChange={this._onChanged}\n        onInput={this._onInputChanged}\n        onKeyDown={this._onKeyDown}\n        onClick={this.props.onClick ? this.props.onClick : this._onClick}\n        data-lpignore={true}\n      />\n    );\n  }\n\n  public focus() {\n    this._inputElement.current && this._inputElement.current.focus();\n  }\n\n  public clear() {\n    this._autoFillEnabled = true;\n    this._updateValue('', false);\n    this._inputElement.current && this._inputElement.current.setSelectionRange(0, 0);\n  }\n\n  public getSnapshotBeforeUpdate(): ICursorLocation | null {\n    const inel = this._inputElement.current;\n\n    if (inel && inel.selectionStart !== this.value.length) {\n      return {\n        start: inel.selectionStart ?? inel.value.length,\n        end: inel.selectionEnd ?? inel.value.length,\n        dir: (inel.selectionDirection as 'forward') || 'backward' || 'none',\n      };\n    }\n    return null;\n  }\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionStart = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    this.setState({ isComposing: true });\n    this._autoFillEnabled = false;\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionUpdate = () => {\n    if (isIE11()) {\n      this._updateValue(this._getCurrentInputValue(), true);\n    }\n  };\n\n  // Composition events are used when the character/text requires several keystrokes to be completed.\n  // Some examples of this are mobile text input and languages like Japanese or Arabic.\n  // Find out more at https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart\n  private _onCompositionEnd = (ev: React.CompositionEvent<HTMLInputElement>) => {\n    const inputValue = this._getCurrentInputValue();\n    this._tryEnableAutofill(inputValue, this.value, false, true);\n    this.setState({ isComposing: false });\n\n    // Due to timing, this needs to be async, otherwise no text will be selected.\n    this._async.setTimeout(() => {\n      // it's technically possible that the value of isComposing is reset during this timeout,\n      // so explicitly trigger this with composing=true here, since it is supposed to be the\n      // update for composition end\n      this._updateValue(this._getCurrentInputValue(), false);\n    }, 0);\n  };\n\n  private _onClick = () => {\n    if (this.value && this.value !== '' && this._autoFillEnabled) {\n      this._autoFillEnabled = false;\n    }\n  };\n\n  private _onKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>) => {\n    if (this.props.onKeyDown) {\n      this.props.onKeyDown(ev);\n    }\n\n    // If the event is actively being composed, then don't alert autofill.\n    // Right now typing does not have isComposing, once that has been fixed any should be removed.\n\n    if (!(ev.nativeEvent as any).isComposing) {\n      // eslint-disable-next-line deprecation/deprecation\n      switch (ev.which) {\n        case KeyCodes.backspace:\n          this._autoFillEnabled = false;\n          break;\n        case KeyCodes.left:\n        case KeyCodes.right:\n          if (this._autoFillEnabled) {\n            this.setState({ inputValue: this.props.suggestedDisplayValue || '' });\n            this._autoFillEnabled = false;\n          }\n          break;\n        default:\n          if (!this._autoFillEnabled) {\n            // eslint-disable-next-line deprecation/deprecation\n            if (this.props.enableAutofillOnKeyPress!.indexOf(ev.which) !== -1) {\n              this._autoFillEnabled = true;\n            }\n          }\n          break;\n      }\n    }\n  };\n\n  private _onInputChanged = (ev: React.FormEvent<HTMLElement>) => {\n    const value: string = this._getCurrentInputValue(ev);\n\n    if (!this.state.isComposing) {\n      this._tryEnableAutofill(value, this.value, (ev.nativeEvent as any).isComposing);\n    }\n\n    // If it is not IE11 and currently composing, update the value\n    if (!(isIE11() && this.state.isComposing)) {\n      const nativeEventComposing = (ev.nativeEvent as any).isComposing;\n      const isComposing = nativeEventComposing === undefined ? this.state.isComposing : nativeEventComposing;\n      this._updateValue(value, isComposing);\n    }\n  };\n\n  private _onChanged = (): void => {\n    // Swallow this event, we don't care about it\n    // We must provide it because React PropTypes marks it as required, but onInput serves the correct purpose\n    return;\n  };\n\n  private _getCurrentInputValue(ev?: React.FormEvent<HTMLElement>): string {\n    if (ev && ev.target && (ev.target as HTMLInputElement).value) {\n      return (ev.target as HTMLInputElement).value;\n    } else if (this.inputElement && this.inputElement.value) {\n      return this.inputElement.value;\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Attempts to enable autofill. Whether or not autofill is enabled depends on the input value,\n   * whether or not any text is selected, and only if the new input value is longer than the old input value.\n   * Autofill should never be set to true if the value is composing. Once compositionEnd is called, then\n   * it should be completed.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent for more information on composition.\n   * @param newValue - new input value\n   * @param oldValue - old input value\n   * @param isComposing - if true then the text is actively being composed and it has not completed.\n   * @param isComposed - if the text is a composed text value.\n   */\n  private _tryEnableAutofill(newValue: string, oldValue: string, isComposing?: boolean, isComposed?: boolean): void {\n    if (\n      !isComposing &&\n      newValue &&\n      this._inputElement.current &&\n      this._inputElement.current.selectionStart === newValue.length &&\n      !this._autoFillEnabled &&\n      (newValue.length > oldValue.length || isComposed)\n    ) {\n      this._autoFillEnabled = true;\n    }\n  }\n\n  /**\n   * Updates the current input value as well as getting a new display value.\n   * @param newValue - The new value from the input\n   */\n  private _updateValue = (newValue: string, composing: boolean) => {\n    // Only proceed if the value is nonempty and is different from the old value\n    // This is to work around the fact that, in IE 11, inputs with a placeholder fire an onInput event on focus\n    if (!newValue && newValue === this.value) {\n      return;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    const { onInputChange, onInputValueChange, updateValueInWillReceiveProps } = this.props;\n    if (onInputChange) {\n      newValue = onInputChange?.(newValue, composing) || '';\n    }\n\n    // if value is controlled in updateValueInWillReceiveProps, then we should not update the value in state now\n    // https://github.com/microsoft/fluentui/issues/18499\n    updateValueInWillReceiveProps\n      ? onInputValueChange?.(newValue, composing)\n      : this.setState({ inputValue: newValue }, () => onInputValueChange?.(newValue, composing));\n  };\n\n  private _getDisplayValue(): string {\n    if (this._autoFillEnabled) {\n      return _getDisplayValue(this.value, this.props.suggestedDisplayValue);\n    }\n\n    return this.value;\n  }\n\n  private _getControlledValue(): string | undefined {\n    const { value } = this.props;\n    if (value === undefined || typeof value === 'string') {\n      return value;\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn(`props.value of Autofill should be a string, but it is ${value} with type of ${typeof value}`);\n\n    return value.toString();\n  }\n}\n/**\n * Returns a string that should be used as the display value.\n * It evaluates this based on whether or not the suggested value starts with the input value\n * and whether or not autofill is enabled.\n * @param inputValue - the value that the input currently has.\n * @param suggestedDisplayValue - the possible full value\n */\nfunction _getDisplayValue(inputValue: string, suggestedDisplayValue?: string): string {\n  let displayValue = inputValue;\n  if (suggestedDisplayValue && inputValue && _doesTextStartWith(suggestedDisplayValue, displayValue)) {\n    displayValue = suggestedDisplayValue;\n  }\n  return displayValue;\n}\n\nfunction _doesTextStartWith(text: string, startWith: string): boolean {\n  if (!text || !startWith) {\n    return false;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    for (const val of [text, startWith]) {\n      if (typeof val !== 'string') {\n        throw new Error(\n          `${\n            Autofill.name\n            // eslint-disable-next-line @fluentui/max-len\n          } received non-string value \"${val}\" of type ${typeof val} from either input's value or suggestedDisplayValue`,\n        );\n      }\n    }\n  }\n\n  return text.toLocaleLowerCase().indexOf(startWith.toLocaleLowerCase()) === 0;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}